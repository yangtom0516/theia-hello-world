{"version":3,"file":"notebookSerializerWorker.js","mappings":"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","sources":["webpack://ipynb/./src/constants.ts","webpack://ipynb/./src/serializers.ts","webpack://ipynb/external node-commonjs \"worker_threads\"","webpack://ipynb/webpack/bootstrap","webpack://ipynb/./src/notebookSerializerWorker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DocumentSelector } from 'vscode';\n\nexport const defaultNotebookFormat = { major: 4, minor: 2 };\nexport const ATTACHMENT_CLEANUP_COMMANDID = 'ipynb.cleanInvalidImageAttachment';\n\nexport const JUPYTER_NOTEBOOK_MARKDOWN_SELECTOR: DocumentSelector = { notebookType: 'jupyter-notebook', language: 'markdown' };\n\n// Copied from NotebookCellKind.Markup as we cannot import it from vscode directly in worker threads.\nexport const NotebookCellKindMarkup = 1;\n// Copied from NotebookCellKind.Code as we cannot import it from vscode directly in worker threads.\nexport const NotebookCellKindCode = 2;\n\nexport enum CellOutputMimeTypes {\n\terror = 'application/vnd.code.notebook.error',\n\tstderr = 'application/vnd.code.notebook.stderr',\n\tstdout = 'application/vnd.code.notebook.stdout'\n}\n\nexport const textMimeTypes = ['text/plain', 'text/markdown', 'text/latex', CellOutputMimeTypes.stderr, CellOutputMimeTypes.stdout];\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as nbformat from '@jupyterlab/nbformat';\nimport type { NotebookCell, NotebookCellData, NotebookCellOutput, NotebookData, NotebookDocument } from 'vscode';\nimport { CellOutputMetadata, type CellMetadata } from './common';\nimport { textMimeTypes, NotebookCellKindMarkup, CellOutputMimeTypes, defaultNotebookFormat } from './constants';\n\nconst textDecoder = new TextDecoder();\n\nexport function createJupyterCellFromNotebookCell(\n\tvscCell: NotebookCellData,\n\tpreferredLanguage: string | undefined,\n): nbformat.IRawCell | nbformat.IMarkdownCell | nbformat.ICodeCell {\n\tlet cell: nbformat.IRawCell | nbformat.IMarkdownCell | nbformat.ICodeCell;\n\tif (vscCell.kind === NotebookCellKindMarkup) {\n\t\tcell = createMarkdownCellFromNotebookCell(vscCell);\n\t} else if (vscCell.languageId === 'raw') {\n\t\tcell = createRawCellFromNotebookCell(vscCell);\n\t} else {\n\t\tcell = createCodeCellFromNotebookCell(vscCell, preferredLanguage);\n\t}\n\treturn cell;\n}\n\n\n/**\n * Sort the JSON to minimize unnecessary SCM changes.\n * Jupyter notbeooks/labs sorts the JSON keys in alphabetical order.\n * https://github.com/microsoft/vscode-python/issues/13155\n */\nexport function sortObjectPropertiesRecursively(obj: any): any {\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map(sortObjectPropertiesRecursively);\n\t}\n\tif (obj !== undefined && obj !== null && typeof obj === 'object' && Object.keys(obj).length > 0) {\n\t\treturn (\n\t\t\tObject.keys(obj)\n\t\t\t\t.sort()\n\t\t\t\t.reduce<Record<string, any>>((sortedObj, prop) => {\n\t\t\t\t\tsortedObj[prop] = sortObjectPropertiesRecursively(obj[prop]);\n\t\t\t\t\treturn sortedObj;\n\t\t\t\t}, {}) as any\n\t\t);\n\t}\n\treturn obj;\n}\n\nexport function getCellMetadata(options: { cell: NotebookCell | NotebookCellData } | { metadata?: { [key: string]: any } }): CellMetadata {\n\tif ('cell' in options) {\n\t\tconst cell = options.cell;\n\t\tconst metadata = {\n\t\t\texecution_count: null,\n\t\t\t// it contains the cell id, and the cell metadata, along with other nb cell metadata\n\t\t\t...(cell.metadata ?? {})\n\t\t} satisfies CellMetadata;\n\t\tif (cell.kind === NotebookCellKindMarkup) {\n\t\t\tdelete (metadata as any).execution_count;\n\t\t}\n\t\treturn metadata;\n\t} else {\n\t\tconst cell = options;\n\t\tconst metadata = {\n\t\t\t// it contains the cell id, and the cell metadata, along with other nb cell metadata\n\t\t\t...(cell.metadata ?? {})\n\t\t};\n\n\t\treturn metadata as CellMetadata;\n\t}\n}\n\nexport function getVSCodeCellLanguageId(metadata: CellMetadata): string | undefined {\n\treturn metadata.metadata?.vscode?.languageId;\n}\nexport function setVSCodeCellLanguageId(metadata: CellMetadata, languageId: string) {\n\tmetadata.metadata = metadata.metadata || {};\n\tmetadata.metadata.vscode = { languageId };\n}\nexport function removeVSCodeCellLanguageId(metadata: CellMetadata) {\n\tif (metadata.metadata?.vscode) {\n\t\tdelete metadata.metadata.vscode;\n\t}\n}\n\nfunction createCodeCellFromNotebookCell(cell: NotebookCellData, preferredLanguage: string | undefined): nbformat.ICodeCell {\n\tconst cellMetadata: CellMetadata = JSON.parse(JSON.stringify(getCellMetadata({ cell })));\n\tcellMetadata.metadata = cellMetadata.metadata || {}; // This cannot be empty.\n\tif (cell.languageId !== preferredLanguage) {\n\t\tsetVSCodeCellLanguageId(cellMetadata, cell.languageId);\n\t} else {\n\t\t// cell current language is the same as the preferred cell language in the document, flush the vscode custom language id metadata\n\t\tremoveVSCodeCellLanguageId(cellMetadata);\n\t}\n\n\tconst codeCell: nbformat.ICodeCell = {\n\t\tcell_type: 'code',\n\t\t// Metadata should always contain the execution_count.\n\t\t// When ever execution summary data changes we will update the metadata to contain the execution count.\n\t\t// Failing to do so means we have a problem.\n\t\t// Also do not read the value of executionSummary here, as its possible user reverted changes to metadata\n\t\t// & in that case execution summary could contain the data, but metadata will not.\n\t\t// In such cases we do not want to re-set the metadata with the value from execution summary (remember, user reverted that).\n\t\texecution_count: cellMetadata.execution_count ?? null,\n\t\tsource: splitMultilineString(cell.value.replace(/\\r\\n/g, '\\n')),\n\t\toutputs: (cell.outputs || []).map(translateCellDisplayOutput),\n\t\tmetadata: cellMetadata.metadata\n\t};\n\tif (cellMetadata?.id) {\n\t\tcodeCell.id = cellMetadata.id;\n\t}\n\treturn codeCell;\n}\n\nfunction createRawCellFromNotebookCell(cell: NotebookCellData): nbformat.IRawCell {\n\tconst cellMetadata = getCellMetadata({ cell });\n\tconst rawCell: any = {\n\t\tcell_type: 'raw',\n\t\tsource: splitMultilineString(cell.value.replace(/\\r\\n/g, '\\n')),\n\t\tmetadata: cellMetadata?.metadata || {} // This cannot be empty.\n\t};\n\tif (cellMetadata?.attachments) {\n\t\trawCell.attachments = cellMetadata.attachments;\n\t}\n\tif (cellMetadata?.id) {\n\t\trawCell.id = cellMetadata.id;\n\t}\n\treturn rawCell;\n}\n\nfunction splitMultilineString(source: nbformat.MultilineString): string[] {\n\tif (Array.isArray(source)) {\n\t\treturn source as string[];\n\t}\n\tconst str = source.toString();\n\tif (str.length > 0) {\n\t\t// Each line should be a separate entry, but end with a \\n if not last entry\n\t\tconst arr = str.split('\\n');\n\t\treturn arr\n\t\t\t.map((s, i) => {\n\t\t\t\tif (i < arr.length - 1) {\n\t\t\t\t\treturn `${s}\\n`;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t})\n\t\t\t.filter(s => s.length > 0); // Skip last one if empty (it's the only one that could be length 0)\n\t}\n\treturn [];\n}\n\nfunction translateCellDisplayOutput(output: NotebookCellOutput): JupyterOutput {\n\tconst customMetadata = output.metadata as CellOutputMetadata | undefined;\n\tlet result: JupyterOutput;\n\t// Possible some other extension added some output (do best effort to translate & save in ipynb).\n\t// In which case metadata might not contain `outputType`.\n\tconst outputType = customMetadata?.outputType as nbformat.OutputType;\n\tswitch (outputType) {\n\t\tcase 'error': {\n\t\t\tresult = translateCellErrorOutput(output);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'stream': {\n\t\t\tresult = convertStreamOutput(output);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'display_data': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'display_data',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {} // This can never be undefined.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase 'execute_result': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'execute_result',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {}, // This can never be undefined.\n\t\t\t\texecution_count:\n\t\t\t\t\ttypeof customMetadata?.executionCount === 'number' ? customMetadata?.executionCount : null // This can never be undefined, only a number or `null`.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase 'update_display_data': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'update_display_data',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {} // This can never be undefined.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tconst isError =\n\t\t\t\toutput.items.length === 1 && output.items.every((item) => item.mime === CellOutputMimeTypes.error);\n\t\t\tconst isStream = output.items.every(\n\t\t\t\t(item) => item.mime === CellOutputMimeTypes.stderr || item.mime === CellOutputMimeTypes.stdout\n\t\t\t);\n\n\t\t\tif (isError) {\n\t\t\t\treturn translateCellErrorOutput(output);\n\t\t\t}\n\n\t\t\t// In the case of .NET & other kernels, we need to ensure we save ipynb correctly.\n\t\t\t// Hence if we have stream output, save the output as Jupyter `stream` else `display_data`\n\t\t\t// Unless we already know its an unknown output type.\n\t\t\tconst outputType: nbformat.OutputType =\n\t\t\t\t<nbformat.OutputType>customMetadata?.outputType || (isStream ? 'stream' : 'display_data');\n\t\t\tlet unknownOutput: nbformat.IUnrecognizedOutput | nbformat.IDisplayData | nbformat.IStream;\n\t\t\tif (outputType === 'stream') {\n\t\t\t\t// If saving as `stream` ensure the mandatory properties are set.\n\t\t\t\tunknownOutput = convertStreamOutput(output);\n\t\t\t} else if (outputType === 'display_data') {\n\t\t\t\t// If saving as `display_data` ensure the mandatory properties are set.\n\t\t\t\tconst displayData: nbformat.IDisplayData = {\n\t\t\t\t\tdata: {},\n\t\t\t\t\tmetadata: {},\n\t\t\t\t\toutput_type: 'display_data'\n\t\t\t\t};\n\t\t\t\tunknownOutput = displayData;\n\t\t\t} else {\n\t\t\t\tunknownOutput = {\n\t\t\t\t\toutput_type: outputType\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (customMetadata?.metadata) {\n\t\t\t\tunknownOutput.metadata = customMetadata.metadata;\n\t\t\t}\n\t\t\tif (output.items.length > 0) {\n\t\t\t\tunknownOutput.data = output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {});\n\t\t\t}\n\t\t\tresult = unknownOutput;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Account for transient data as well\n\t// `transient.display_id` is used to update cell output in other cells, at least thats one use case we know of.\n\tif (result && customMetadata && customMetadata.transient) {\n\t\tresult.transient = customMetadata.transient;\n\t}\n\treturn result;\n}\n\nfunction translateCellErrorOutput(output: NotebookCellOutput): nbformat.IError {\n\t// it should have at least one output item\n\tconst firstItem = output.items[0];\n\t// Bug in VS Code.\n\tif (!firstItem.data) {\n\t\treturn {\n\t\t\toutput_type: 'error',\n\t\t\tename: '',\n\t\t\tevalue: '',\n\t\t\ttraceback: []\n\t\t};\n\t}\n\tconst originalError: undefined | nbformat.IError = output.metadata?.originalError;\n\tconst value: Error = JSON.parse(textDecoder.decode(firstItem.data));\n\treturn {\n\t\toutput_type: 'error',\n\t\tename: value.name,\n\t\tevalue: value.message,\n\t\t// VS Code needs an `Error` object which requires a `stack` property as a string.\n\t\t// Its possible the format could change when converting from `traceback` to `string` and back again to `string`\n\t\t// When .NET stores errors in output (with their .NET kernel),\n\t\t// stack is empty, hence store the message instead of stack (so that somethign gets displayed in ipynb).\n\t\ttraceback: originalError?.traceback || splitMultilineString(value.stack || value.message || '')\n\t};\n}\n\n\nfunction getOutputStreamType(output: NotebookCellOutput): string | undefined {\n\tif (output.items.length > 0) {\n\t\treturn output.items[0].mime === CellOutputMimeTypes.stderr ? 'stderr' : 'stdout';\n\t}\n\n\treturn;\n}\n\ntype JupyterOutput =\n\t| nbformat.IUnrecognizedOutput\n\t| nbformat.IExecuteResult\n\t| nbformat.IDisplayData\n\t| nbformat.IStream\n\t| nbformat.IError;\n\nfunction convertStreamOutput(output: NotebookCellOutput): JupyterOutput {\n\tconst outputs: string[] = [];\n\toutput.items\n\t\t.filter((opit) => opit.mime === CellOutputMimeTypes.stderr || opit.mime === CellOutputMimeTypes.stdout)\n\t\t.map((opit) => textDecoder.decode(opit.data))\n\t\t.forEach(value => {\n\t\t\t// Ensure each line is a separate entry in an array (ending with \\n).\n\t\t\tconst lines = value.split('\\n');\n\t\t\t// If the last item in `outputs` is not empty and the first item in `lines` is not empty, then concate them.\n\t\t\t// As they are part of the same line.\n\t\t\tif (outputs.length && lines.length && lines[0].length > 0) {\n\t\t\t\toutputs[outputs.length - 1] = `${outputs[outputs.length - 1]}${lines.shift()!}`;\n\t\t\t}\n\t\t\tfor (const line of lines) {\n\t\t\t\toutputs.push(line);\n\t\t\t}\n\t\t});\n\n\tfor (let index = 0; index < (outputs.length - 1); index++) {\n\t\toutputs[index] = `${outputs[index]}\\n`;\n\t}\n\n\t// Skip last one if empty (it's the only one that could be length 0)\n\tif (outputs.length && outputs[outputs.length - 1].length === 0) {\n\t\toutputs.pop();\n\t}\n\n\tconst streamType = getOutputStreamType(output) || 'stdout';\n\n\treturn {\n\t\toutput_type: 'stream',\n\t\tname: streamType,\n\t\ttext: outputs\n\t};\n}\n\nfunction convertOutputMimeToJupyterOutput(mime: string, value: Uint8Array) {\n\tif (!value) {\n\t\treturn '';\n\t}\n\ttry {\n\t\tif (mime === CellOutputMimeTypes.error) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn JSON.parse(stringValue);\n\t\t} else if (mime.startsWith('text/') || textMimeTypes.includes(mime)) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn splitMultilineString(stringValue);\n\t\t} else if (mime.startsWith('image/') && mime !== 'image/svg+xml') {\n\t\t\t// Images in Jupyter are stored in base64 encoded format.\n\t\t\t// VS Code expects bytes when rendering images.\n\t\t\tif (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n\t\t\t\treturn Buffer.from(value).toString('base64');\n\t\t\t} else {\n\t\t\t\treturn btoa(value.reduce((s: string, b: number) => s + String.fromCharCode(b), ''));\n\t\t\t}\n\t\t} else if (mime.toLowerCase().includes('json')) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn stringValue.length > 0 ? JSON.parse(stringValue) : stringValue;\n\t\t} else if (mime === 'image/svg+xml') {\n\t\t\treturn splitMultilineString(textDecoder.decode(value));\n\t\t} else {\n\t\t\treturn textDecoder.decode(value);\n\t\t}\n\t} catch (ex) {\n\t\treturn '';\n\t}\n}\n\nexport function createMarkdownCellFromNotebookCell(cell: NotebookCellData): nbformat.IMarkdownCell {\n\tconst cellMetadata = getCellMetadata({ cell });\n\tconst markdownCell: any = {\n\t\tcell_type: 'markdown',\n\t\tsource: splitMultilineString(cell.value.replace(/\\r\\n/g, '\\n')),\n\t\tmetadata: cellMetadata?.metadata || {} // This cannot be empty.\n\t};\n\tif (cellMetadata?.attachments) {\n\t\tmarkdownCell.attachments = cellMetadata.attachments;\n\t}\n\tif (cellMetadata?.id) {\n\t\tmarkdownCell.id = cellMetadata.id;\n\t}\n\treturn markdownCell;\n}\n\nexport function pruneCell(cell: nbformat.ICell): nbformat.ICell {\n\t// Source is usually a single string on input. Convert back to an array\n\tconst result: nbformat.ICell = {\n\t\t...cell,\n\t\tsource: splitMultilineString(cell.source)\n\t};\n\n\t// Remove outputs and execution_count from non code cells\n\tif (result.cell_type !== 'code') {\n\t\tdelete (<any>result).outputs;\n\t\tdelete (<any>result).execution_count;\n\t} else {\n\t\t// Clean outputs from code cells\n\t\tresult.outputs = result.outputs ? (result.outputs as nbformat.IOutput[]).map(fixupOutput) : [];\n\t}\n\n\treturn result;\n}\nconst dummyStreamObj: nbformat.IStream = {\n\toutput_type: 'stream',\n\tname: 'stdout',\n\ttext: ''\n};\nconst dummyErrorObj: nbformat.IError = {\n\toutput_type: 'error',\n\tename: '',\n\tevalue: '',\n\ttraceback: ['']\n};\nconst dummyDisplayObj: nbformat.IDisplayData = {\n\toutput_type: 'display_data',\n\tdata: {},\n\tmetadata: {}\n};\nconst dummyExecuteResultObj: nbformat.IExecuteResult = {\n\toutput_type: 'execute_result',\n\tname: '',\n\texecution_count: 0,\n\tdata: {},\n\tmetadata: {}\n};\nconst AllowedCellOutputKeys = {\n\t['stream']: new Set(Object.keys(dummyStreamObj)),\n\t['error']: new Set(Object.keys(dummyErrorObj)),\n\t['display_data']: new Set(Object.keys(dummyDisplayObj)),\n\t['execute_result']: new Set(Object.keys(dummyExecuteResultObj))\n};\n\nfunction fixupOutput(output: nbformat.IOutput): nbformat.IOutput {\n\tlet allowedKeys: Set<string>;\n\tswitch (output.output_type) {\n\t\tcase 'stream':\n\t\tcase 'error':\n\t\tcase 'execute_result':\n\t\tcase 'display_data':\n\t\t\tallowedKeys = AllowedCellOutputKeys[output.output_type];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn output;\n\t}\n\tconst result = { ...output };\n\tfor (const k of Object.keys(output)) {\n\t\tif (!allowedKeys.has(k)) {\n\t\t\tdelete result[k];\n\t\t}\n\t}\n\treturn result;\n}\n\n\nexport function serializeNotebookToString(data: NotebookData): string {\n\tconst notebookContent = getNotebookMetadata(data);\n\t// use the preferred language from document metadata or the first cell language as the notebook preferred cell language\n\tconst preferredCellLanguage = notebookContent.metadata?.language_info?.name ?? data.cells.find(cell => cell.kind === 2)?.languageId;\n\n\tnotebookContent.cells = data.cells\n\t\t.map(cell => createJupyterCellFromNotebookCell(cell, preferredCellLanguage))\n\t\t.map(pruneCell);\n\n\tconst indentAmount = data.metadata && 'indentAmount' in data.metadata && typeof data.metadata.indentAmount === 'string' ?\n\t\tdata.metadata.indentAmount :\n\t\t' ';\n\n\treturn serializeNotebookToJSON(notebookContent, indentAmount);\n}\nfunction serializeNotebookToJSON(notebookContent: Partial<nbformat.INotebookContent>, indentAmount: string): string {\n\t// ipynb always ends with a trailing new line (we add this so that SCMs do not show unnecessary changes, resulting from a missing trailing new line).\n\tconst sorted = sortObjectPropertiesRecursively(notebookContent);\n\n\treturn JSON.stringify(sorted, undefined, indentAmount) + '\\n';\n}\n\nexport function getNotebookMetadata(document: NotebookDocument | NotebookData) {\n\tconst existingContent: Partial<nbformat.INotebookContent> = document.metadata || {};\n\tconst notebookContent: Partial<nbformat.INotebookContent> = {};\n\tnotebookContent.cells = existingContent.cells || [];\n\tnotebookContent.nbformat = existingContent.nbformat || defaultNotebookFormat.major;\n\tnotebookContent.nbformat_minor = existingContent.nbformat_minor ?? defaultNotebookFormat.minor;\n\tnotebookContent.metadata = existingContent.metadata || {};\n\treturn notebookContent;\n}\n","module.exports = require(\"worker_threads\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { parentPort } from 'worker_threads';\nimport { serializeNotebookToString } from './serializers';\nimport type { NotebookData } from 'vscode';\n\n\nif (parentPort) {\n\tparentPort.on('message', ({ id, data }: { id: string; data: NotebookData }) => {\n\t\tif (parentPort) {\n\t\t\tconst json = serializeNotebookToString(data);\n\t\t\tconst bytes = new TextEncoder().encode(json);\n\t\t\tparentPort.postMessage({ id, data: bytes });\n\t\t}\n\t});\n}\n"],"names":["CellOutputMimeTypes","defaultNotebookFormat","major","minor","ATTACHMENT_CLEANUP_COMMANDID","JUPYTER_NOTEBOOK_MARKDOWN_SELECTOR","notebookType","language","NotebookCellKindMarkup","NotebookCellKindCode","textMimeTypes","stderr","stdout","metadata","vscode","languageId","data","notebookContent","getNotebookMetadata","preferredCellLanguage","language_info","name","cells","find","cell","kind","map","createJupyterCellFromNotebookCell","pruneCell","indentAmount","sorted","sortObjectPropertiesRecursively","JSON","stringify","undefined","serializeNotebookToJSON","textDecoder","TextDecoder","vscCell","preferredLanguage","createMarkdownCellFromNotebookCell","cellMetadata","getCellMetadata","rawCell","cell_type","source","splitMultilineString","value","replace","attachments","id","createRawCellFromNotebookCell","parse","setVSCodeCellLanguageId","removeVSCodeCellLanguageId","codeCell","execution_count","outputs","translateCellDisplayOutput","createCodeCellFromNotebookCell","obj","Array","isArray","Object","keys","length","sort","reduce","sortedObj","prop","options","str","toString","arr","split","s","i","filter","output","customMetadata","result","outputType","translateCellErrorOutput","convertStreamOutput","output_type","items","prev","curr","mime","convertOutputMimeToJupyterOutput","executionCount","isError","every","item","error","isStream","unknownOutput","transient","firstItem","ename","evalue","traceback","originalError","decode","message","stack","opit","forEach","lines","shift","line","push","index","pop","streamType","getOutputStreamType","text","stringValue","startsWith","includes","Buffer","from","btoa","b","String","fromCharCode","toLowerCase","ex","markdownCell","fixupOutput","AllowedCellOutputKeys","Set","allowedKeys","k","has","document","existingContent","nbformat","nbformat_minor","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","parentPort","on","json","serializeNotebookToString","bytes","TextEncoder","encode","postMessage"],"sourceRoot":""}